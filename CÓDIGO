//******************************************/
// Universidad del Valle de Guatemala
// BE3029 - Electronica Digital 2
// Paulina Martínez
// 01/09/2025
// Proyecto #1: Sensor de temperatura
// MCU: ESP32 dev kit 1.1
//******************************************/

//******************************************/
// Librerias
//******************************************/
#include <Arduino.h>
#include <stdint.h>
#include <ESP32Servo.h>
#include <driver/ledc.h>
#include <driver/adc.h>
#include "Display.h"
#include "config.h"
#include "AdafruitIO_WiFi.h"
//******************************************/
// Definiciones
//******************************************/
//Sensor de temperatura en pin ADC
#define sensortemp 34
//Botón para detectar el cambio de temperatura
#define boton 22 //En pull down 
//Leds para el semáforo
#define LED_V 5 //Led verde
#define LED_A 19 //Led amarilla
#define LED_R 21 //Led roja
/*Segmentos del display
#define dA 13
#define dB 27
#define dC 16
#define dD 18
#define dE 25
#define dF 33
#define dG 23
#define dP 17 //Punto decimal*/
//Definición de displays(3)
#define display1 32
#define display2 26
#define display3 14
//Servo
#define pinservo 2

//******************************************/
// Prototipos de funciones
//******************************************/
//Prototipo de funciones para actualizar los estados de los leds
void actualizarpwm(float temp);

//Prototipo de funciones para actualizar el movimiento del servo
void moverservo(float temp);

//Prototipo de funciones para actualizar el display
void actualizardisplay(float temp);
void multiplexdisplay(void);
//void digitostemp(void);
//void initpinsdisplay(void);

//Prototipo de funciones para lectura del ADC
void adcpromedio(void);
void adcraw(void);

//******************************************/
// Variables globales
//******************************************/
//Variables para cambio de color de leds
//typedef enum color {rojo=0, amarillo, verde} color;
//volatile color colorActual = rojo;

//Variables para hacer cambios de ángulos
typedef enum angulos {s0, s1, s2} angulos;
volatile uint8_t posicionservo = 0;

//Variables para el antirrebote del boton
const long tiempo = 200;
volatile bool lectura = false;
volatile uint32_t lastboton = 0;

//Lectura del adc
int adcRAW=0;

//Variable para lectura del sensor de temperatura
float promedioLecturas=0;
float temp=0.0;
float voltaje=0;

//******************************************/
// ISRs Rutinas de Interrupcion
//******************************************/
//Prototipo de función para configurar el PWM
void initPWM_V();
void initPWM_R();
void initPWM_A();
void initPWM_servo();

//Prototipo de función para el botón con ISR
void initboton();
void IRAM_ATTR boton_ISR();

//******************************************/
// Configuracion
//******************************************/
//Configuración del PWM: channels
#define pwmChannel_R 0
#define pwmChannel_A 1
#define pwmChannel_V 2
#define pwmChannel_servo 3

//Configuración del PWM:frecuencia
#define freqpwm 50

//Configuración del PWM: resolución
#define respwm 10

//Configuración de adafruit
AdafruitIO_Feed *canaltemp = io.feed("Temperatura - proyecto 1 - digital 2");

void setup() {
  //Inicio de comunicación serial
  Serial.begin(115200);

  //Definición del botón como pin de entrada
  pinMode(boton, INPUT_PULLDOWN);

  //Definición de displays como output
  pinMode(display1, OUTPUT);
  pinMode(display2, OUTPUT);
  pinMode(display3, OUTPUT);

  //Apagar displays - como inicializarlos
  digitalWrite(display1, LOW);
  digitalWrite(display2, LOW);
  digitalWrite(display3, LOW);

  //Inicialización de funciones PWM
  initPWM_A();
  initPWM_R();
  initPWM_V();
  initPWM_servo();

  //Inicialización el botón
  initboton();

  //Configuración inicial del servo
  posicionservo=0;
  //moverservo();

  //Inicialización del display
  configDisplay7();

  //Conexión a adafruit
  while(!Serial);
  Serial.print("Conectando a Adafruit");
  io.connect();
  while(io.status()<AIO_CONNECTED){
    Serial.print(".");
    delay(500);
  }
  //Adafruit conectado
  Serial.println();
  Serial.println(io.statusText());

}
//******************************************/
// Loop Principal
//******************************************/
void loop() {
//Corremos adafruit
io.run();

  //Lectura del sensor de temperatura con botón
  if(lectura){
    //Obtención de datos solo al presionar el botón
    adcraw();
    adcpromedio();
    Serial.print("Temperatura (°C): ");
    Serial.println(temp);
    //Actualización del semáforo
    actualizarpwm(temp);
    //Movimiento del servo
    moverservo(temp);
    //Actualización del display
    actualizardisplay(temp);
    //delay(1000);
    Serial.print("Sending ->");
    Serial.println(temp);
    canaltemp->save(temp);
    delay(3000);
    lectura=false;
  }
}
//******************************************/
// Otras funciones
//******************************************/
//Funciones del PWM
void initPWM_A(){
  ledcSetup(pwmChannel_A, freqpwm, respwm);
  ledcAttachPin(LED_A, pwmChannel_A);
}

void initPWM_R(){
  ledcSetup(pwmChannel_R, freqpwm, respwm);
  ledcAttachPin(LED_R, pwmChannel_R);
}

void initPWM_V(){
  ledcSetup(pwmChannel_V, freqpwm, respwm);
  ledcAttachPin(LED_V, pwmChannel_V);
}

void initPWM_servo(){
  ledcSetup(pwmChannel_servo, freqpwm, respwm);
  ledcAttachPin(pinservo, pwmChannel_servo);
}

//Función de inicialización del botón 
void initboton(){
  attachInterrupt(digitalPinToInterrupt(boton), boton_ISR, RISING);
}

//Función ISR para el botón
void IRAM_ATTR boton_ISR(){
  uint32_t tiempoactual = millis();
  if (tiempoactual - lastboton > tiempo) {
    lectura=true;
    lastboton=tiempoactual;
  }
}
//Funciones para ADC
//ADC raw
void adcraw(){
  adcRAW=analogRead(sensortemp);
}

//Promedio de lecturas para evitar ruido
void adcpromedio(){
  int numeroLecturas=10;
  int sumaLecturas=0;
  for (int k=0; k<numeroLecturas; k++){
    sumaLecturas+=analogRead(sensortemp);
    delay(1);
  }
  promedioLecturas=sumaLecturas/(numeroLecturas*1.0);
  voltaje = promedioLecturas*(5/4095.0); 
  temp = (voltaje*100)+7; //Corrimiento de lectura para arreglar la escala del sensor
}


//Función del semáforo
void actualizarpwm(float temp){
  ledcWrite(pwmChannel_A, 0);
  ledcWrite(pwmChannel_V, 0);
  ledcWrite(pwmChannel_R, 0);
  if (temp<22) {
    ledcWrite(pwmChannel_V, 255);
  }
  else if (temp>=22 && temp<25){
    ledcWrite(pwmChannel_A, 255);
  }
  else if (temp>=25){
    ledcWrite(pwmChannel_R, 255);
  }
}

//Función del servo
void moverservo (float temp){
  int duty = 51;
  if (temp<22){
    duty = 77;
  }
  else if (temp>=22 && temp<25){
    duty=77;
  }
  else if (temp>=25){
    duty=102;
  }
  ledcWrite(pwmChannel_servo, duty);
}

//Función del display
void actualizardisplay(float temp){
  int numero=int(temp*10);
  if (numero>999){
    numero=999;
  }
  int decenas=numero/100;
  int unidades=(temp-(decenas*100))/10;
  int decimal=temp-(unidades*10);
  unsigned long tiempodisplay=millis();
}

/*void multiplexdisplay(){
  static unsigned long last= 0;
  static int estado = 0;
  if (millis()-last>3){
    switch (estado){
      case 0:
        digitalWrite(display1,HIGH);
        digitalWrite(display2,LOW);
        digitalWrite(display3,LOW);
        desplegarNumero(decenas);
        desplegarPunto(0);
        break;
      case 1:
        digitalWrite(display1,LOW);
        digitalWrite(display2,HIGH);
        digitalWrite(display3,LOW);
        desplegarNumero(unidades);
        desplegarPunto(1); // punto en la unidad
        break;
      case 2:
        digitalWrite(display1,LOW);
        digitalWrite(display2,LOW);
        digitalWrite(display3,HIGH);
        desplegarNumero(decimal);
        desplegarPunto(0);
        break;
    //default:
      //break;
    }
    estado=(estado+1)%3;
  }
}*/
/* while(millis()-tiempodisplay<500){
    //Escritura de centenas con punto
    digitalWrite(display1, HIGH);
    digitalWrite(display2, LOW);
    digitalWrite(display3, LOW);
    //if (decenas<0 || temp<10){
    desplegarNumero(decenas);
    //}
    else{
      desplegarNumero(0);
    }
    desplegarPunto(0);
    delay(3);
    //Escritura de decenas
    digitalWrite(display1, LOW);
    digitalWrite(display2, HIGH);
    digitalWrite(display3, LOW);
    desplegarNumero(unidades);
    desplegarPunto(1);
    delay(3);
    //Escritura de unidades
    digitalWrite(display1, LOW);
    digitalWrite(display2, LOW);
    digitalWrite(display3, HIGH);
    desplegarNumero(decimal);
    desplegarPunto(0);
    delay(3);
  }
  /*Apagar displays
  digitalWrite(display1,HIGH);
  digitalWrite(display2,HIGH);
  digitalWrite(display3,HIGH);*/
