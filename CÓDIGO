//******************************************/
// Universidad del Valle de Guatemala
// BE3029 - Electronica Digital 2
// Paulina Martínez
// 01/09/2025
// Proyecto #1: Sensor de temperatura
// MCU: ESP32 dev kit 1.1
//******************************************/

//******************************************/
// Librerias
//******************************************/
#include <Arduino.h>
#include <stdint.h>
#include <ESP32Servo.h>
#include <driver/ledc.h>
#include <driver/adc.h>
//******************************************/
// Definiciones
//******************************************/
//Sensor de temperatura en pin ADC
#define sensortemp 34
//Botón para detectar el cambio de temperatura
#define boton 22 //En pull down 
//Leds para el semáforo
#define LED_V 5 //Led verde
#define LED_A 19 //Led amarilla
#define LED_R 21 //Led roja
//Segmentos del display
#define dA 13
#define dB 27
#define dC 16
#define dD 18
#define dE 25
#define dF 33
#define dG 23
#define dP 17 //Punto decimal 
//Display (3)
#define display1 32
#define display2 26
#define display3 14
//Servo
#define pinservo 2


//******************************************/
// Prototipos de funciones
//******************************************/
//Prototipo de funciones para actualizar los estados de los leds
void actualizarpwm(float temp);

//Prototipo de funciones para actualizar el movimiento del servo
void moverservo(void);

//Prototipo de funciones para actualizar el display
void actualizardisplay(void);
void digitostemp(void);
void initpinsdisplay(void);

//Prototipo de funciones para lectura del ADC
void adcpromedio(void);
void adcraw(void);

//******************************************/
// Variables globales
//******************************************/
//Variables para cambio de color de leds
//typedef enum color {rojo=0, amarillo, verde} color;
//volatile color colorActual = rojo;

//Variables para hacer cambios de ángulos
typedef enum angulos {s0, s1, s2} angulos;
volatile uint8_t posicionservo = 0;

//Variables para el antirrebote del boton
const long tiempo = 100;
volatile uint32_t lastboton = 0;

//Lectura del adc
int adcRAW;

//Variable para lectura del sensor de temperatura
float promedioLecturas;
float temp;
float voltaje;

//******************************************/
// ISRs Rutinas de Interrupcion
//******************************************/
//Prototipo de función para configurar el PWM
void initPWM_V();
void initPWM_R();
void initPWM_A();
void initPWM_servo();

//Prototipo de función para el botón con ISR
void initboton();
void IRAM_ATTR boton_ISR();

//******************************************/
// Configuracion
//******************************************/
//Configuración del PWM: channels
#define pwmChannel_R 0
#define pwmChannel_A 1
#define pwmChannel_V 2
#define pwmChannel_servo 3

//Configuración del PWM:frecuencia
#define freqpwm 50

//Configuración del PWM: resolución
#define respwm 10

void setup() {
  //Inicio de comunicación serial
  Serial.begin(115200);

  //Definición de pines de entrada y salida
  pinMode(boton, INPUT_PULLDOWN);
  pinMode(LED_A, OUTPUT);
  pinMode(LED_R, OUTPUT);
  pinMode(LED_V, OUTPUT);
  
  //Inicialización de funciones PWM
  initPWM_A();
  initPWM_R();
  initPWM_V();
  initPWM_servo();

  //Inicialización de configuración de ISR
  initboton();

  //Configuración inicial del servo
  posicionservo=0;
  //moverservo();

}
//******************************************/
// Loop Principal
//******************************************/
void loop() {
  //Lectura del sensor de temperatura
  adcraw();
  adcpromedio();
  Serial.print("Promedio: ");
  Serial.println(promedioLecturas);
  Serial.print("ADC RAW: ");
  Serial.println(adcRAW);
  Serial.print("Voltaje: ");
  Serial.println(voltaje);
  Serial.print("Temperatura (°C): ");
  Serial.println(temp);
  delay(1000);
  //Actualización de leds
  actualizarpwm(temp);

  //Actualización del servo
  //moverservo();
}
//******************************************/
// Otras funciones
//******************************************/
//Funciones del PWM
void initPWM_A(){
  ledcSetup(pwmChannel_A, freqpwm, respwm);
  ledcAttachPin(LED_A, pwmChannel_A);
}

void initPWM_R(){
  ledcSetup(pwmChannel_R, freqpwm, respwm);
  ledcAttachPin(LED_R, pwmChannel_R);
}

void initPWM_V(){
  ledcSetup(pwmChannel_V, freqpwm, respwm);
  ledcAttachPin(LED_V, pwmChannel_V);
}

void initPWM_servo(){
  ledcSetup(pwmChannel_servo, freqpwm, respwm);
  ledcAttachPin(pinservo, pwmChannel_servo);
}

//Función de inicialización del botón 
void initboton(){
  attachInterrupt(digitalPinToInterrupt(boton), boton_ISR, RISING);
}

//Función ISR para el botón
void IRAM_ATTR boton_ISR(){
  uint32_t tiempoactual = millis();
  if (tiempoactual - lastboton > tiempo) {
    actualizarpwm(temp);
    lastboton=tiempoactual;
  }
}
//Funciones para ADC
//ADC raw
void adcraw(){
  adcRAW=analogRead(sensortemp);
}

//Promedio de lecturas para evitar ruido
void adcpromedio(){
  int numeroLecturas=10;
  int sumaLecturas=0;
  for (int k=0; k<numeroLecturas; k++){
    sumaLecturas+=analogRead(sensortemp);
    delay(1);
  }
  promedioLecturas=sumaLecturas/(numeroLecturas*1.0);
  voltaje = promedioLecturas*(5/4095.0); 
  temp = (voltaje*100)+7; //Corrimiento de lectura para arreglar la escala del sensor
}


//Funciones del semáforo
void actualizarpwm(float temp){
  ledcWrite(pwmChannel_A, 0);
  ledcWrite(pwmChannel_V, 0);
  ledcWrite(pwmChannel_R, 0);
  if (temp<22) {
    ledcWrite(pwmChannel_V, 255);
  }
  if (temp>=22 && temp<25){
    ledcWrite(pwmChannel_A, 255);
  }
  if (temp>=25){
    ledcWrite(pwmChannel_R, 255);
  }
}
