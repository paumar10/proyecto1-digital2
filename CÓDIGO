//******************************************/
// Universidad del Valle de Guatemala
// BE3029 - Electronica Digital 2
// Paulina Martínez
// 01/09/2025
// Proyecto #1: Sensor de temperatura
// MCU: ESP32 dev kit 1.1
//******************************************/

//******************************************/
// Librerias
//******************************************/
#include <Arduino.h>
#include <stdint.h>
#include <ESP32Servo.h>
#include <driver/ledc.h>
#include <driver/adc.h>
#include "Display.h"
//******************************************/
// Definiciones
//******************************************/
//Sensor de temperatura en pin ADC
#define sensortemp 34
//Botón para detectar el cambio de temperatura
#define boton 22 //En pull down 
//Leds para el semáforo
#define LED_V 5 //Led verde
#define LED_A 19 //Led amarilla
#define LED_R 21 //Led roja
//Segmentos del display
/*#define dA 13
#define dB 27
#define dC 16
#define dD 18
#define dE 25
#define dF 33
#define dG 23
#define dP 17 //Punto decimal */
//Display (3)
#define display1 32
#define display2 26
#define display3 14
//Servo
#define pinservo 2


//******************************************/
// Prototipos de funciones
//******************************************/
//Prototipo de funciones para actualizar los estados de los leds
void actualizarpwm(float temp);

//Prototipo de funciones para actualizar el movimiento del servo
void moverservo(float temp);

//Prototipo de funciones para actualizar el display
void actualizardisplay(float temperatura);
void multiplexdisplay(void);

//Prototipo de funciones para lectura del ADC
void adcpromedio(void);
void adcraw(void);

//******************************************/
// Variables globales
//******************************************/
//Variables para cambio de color de leds
//typedef enum color {rojo=0, amarillo, verde} color;
//volatile color colorActual = rojo;

/*Variables para hacer cambios de ángulos
typedef enum angulos {s0, s1, s2} angulos;*/
volatile uint8_t posicionservo = 0;

//Variables para el antirrebote del boton
const long tiempo = 200;
volatile bool lectura = false;
volatile uint32_t lastboton = 0;

//Lectura del adc
int adcRAW=0;

//Variables para lectura del sensor de temperatura
float promedioLecturas=0;
float temp=0.0;
float voltaje=0;

//Variables para el display
int decena = 0;
int unidad = 0;
int decimal =0;

//******************************************/
// ISRs Rutinas de Interrupcion
//******************************************/
//Prototipo de función para configurar el PWM
void initPWM_V();
void initPWM_R();
void initPWM_A();
void initPWM_servo();

//Prototipo de función para el botón con ISR
void initboton();
void IRAM_ATTR boton_ISR();

//******************************************/
// Configuracion
//******************************************/
//Configuración del PWM: channels
#define pwmChannel_R 0
#define pwmChannel_A 1
#define pwmChannel_V 2
#define pwmChannel_servo 3

//Configuración del PWM:frecuencia
#define freqpwm 50

//Configuración del PWM: resolución
#define respwm 10

void setup() {
  //Inicio de comunicación serial
  Serial.begin(115200);

  //Definición del botón como pin de entrada
  pinMode(boton, INPUT_PULLDOWN);

  //Definición de displays como output
  pinMode(display1, OUTPUT);
  pinMode(display2, OUTPUT);
  pinMode(display3, OUTPUT);

  /*pinMode(dA, OUTPUT);
  pinMode(dB, OUTPUT);
  pinMode(dC, OUTPUT);
  pinMode(dD, OUTPUT);
  pinMode(dE, OUTPUT);
  pinMode(dF, OUTPUT);
  pinMode(dG, OUTPUT);
  pinMode(dP, OUTPUT);*/

  //Apagar displays - como inicializarlos
  digitalWrite(display1, HIGH);
  digitalWrite(display2, HIGH);
  digitalWrite(display3, HIGH);

  //Inicialización de funciones PWM
  initPWM_A();
  initPWM_R();
  initPWM_V();
  initPWM_servo();

  //Inicialización el botón
  initboton();

  //Configuración inicial del servo
  posicionservo=0;

  //Configuración del display
  configDisplay7();


}
//******************************************/
// Loop Principal
//******************************************/
void loop() {
  //Lectura del sensor de temperatura con botón
  if(lectura){
    adcraw();
    adcpromedio();
    /*Serial.print("Promedio: ");
    Serial.println(promedioLecturas);
    Serial.print("ADC RAW: ");
    Serial.println(adcRAW);
    Serial.print("Voltaje: ");
    Serial.println(voltaje);*/
    Serial.print("Temperatura (°C): ");
    Serial.println(temp);
    actualizarpwm(temp);
    moverservo(temp);
    actualizardisplay(temp);
    //delay(1000);
    lectura=false;
  }

  //Mostrar siempre los valores del display
  multiplexdisplay();

  //Actualización de leds
  //actualizarpwm(temp);

  //Actualización del servo
  //moverservo();
}
//******************************************/
// Otras funciones
//******************************************/
//Funciones del PWM
void initPWM_A(){
  ledcSetup(pwmChannel_A, freqpwm, respwm);
  ledcAttachPin(LED_A, pwmChannel_A);
}

void initPWM_R(){
  ledcSetup(pwmChannel_R, freqpwm, respwm);
  ledcAttachPin(LED_R, pwmChannel_R);
}

void initPWM_V(){
  ledcSetup(pwmChannel_V, freqpwm, respwm);
  ledcAttachPin(LED_V, pwmChannel_V);
}

void initPWM_servo(){
  ledcSetup(pwmChannel_servo, freqpwm, respwm);
  ledcAttachPin(pinservo, pwmChannel_servo);
}

//Función de inicialización del botón 
void initboton(){
  attachInterrupt(digitalPinToInterrupt(boton), boton_ISR, RISING);
}

//Función ISR para el botón
void IRAM_ATTR boton_ISR(){
  uint32_t tiempoactual = millis();
  if (tiempoactual - lastboton > tiempo) {
    lectura=true;
    lastboton=tiempoactual;
  }
}
//Funciones para ADC
//ADC raw
void adcraw(){
  adcRAW=analogRead(sensortemp);
}

//Promedio de lecturas para evitar ruido
void adcpromedio(){
  int numeroLecturas=10;
  int sumaLecturas=0;
  for (int k=0; k<numeroLecturas; k++){
    sumaLecturas+=analogRead(sensortemp);
    delay(1);
  }
  promedioLecturas=sumaLecturas/(numeroLecturas*1.0);
  voltaje = promedioLecturas*(5/4095.0); 
  temp = (voltaje*100)+7; //Corrimiento de lectura para arreglar la escala del sensor
}


//Funciones del semáforo
void actualizarpwm(float temp){
  ledcWrite(pwmChannel_A, 0);
  ledcWrite(pwmChannel_V, 0);
  ledcWrite(pwmChannel_R, 0);
  if (temp<22) {
    ledcWrite(pwmChannel_V, 255);
  }
  else if (temp>=22 && temp<25){
    ledcWrite(pwmChannel_A, 255);
  }
  else if (temp>=25){
    ledcWrite(pwmChannel_R, 255);
  }
}

//Función para mover el servo
void moverservo (float temp){
  int duty = 51;
  if (temp<22){
    duty = 77;
  }
  else if (temp>=22 && temp<25){
    duty=77;
  }
  else if (temp>=25){
    duty=102;
  }
  ledcWrite(pwmChannel_servo, duty);
}

//Función para el display
void actualizardisplay(float temperatura){
  int numero=(int)roundf(temperatura*10.0f);
  if (numero>999){
    numero=999;
  }
  if (numero<0){
    numero=0;
  }
  decena=numero/100;
  unidad=(numero/10)%10;
  decimal=(numero%10);
  //unsigned long tiempodisplay=millis();
  //while(millis()-tiempodisplay<500){
    //Display 1
    digitalWrite(display1, HIGH);
    digitalWrite(display2, LOW);
    digitalWrite(display3, LOW);
    desplegarNumero(decena);
    desplegarPunto(0);
    delay(3);
    //Display 2
    digitalWrite(display1, LOW);
    digitalWrite(display2, HIGH);
    digitalWrite(display3, LOW);
    desplegarNumero(unidad);
    desplegarPunto(1);
    delay(3);
    //Display 3
    digitalWrite(display1, LOW);
    digitalWrite(display2, LOW);
    digitalWrite(display3, HIGH);
    desplegarNumero(decimal);
    desplegarPunto(0);
    delay(3);
  //}
  Serial.printf("Digitos: %d %d.%d\n", decena, unidad, decimal);
}

void multiplexdisplay(void){
  digitalWrite(display1, HIGH);
    digitalWrite(display2, LOW);
    digitalWrite(display3, LOW);
    desplegarNumero(decena);
    desplegarPunto(0);
    delay(3);
    //Display 2
    digitalWrite(display1, LOW);
    digitalWrite(display2, HIGH);
    digitalWrite(display3, LOW);
    desplegarNumero(unidad);
    desplegarPunto(1);
    delay(3);
    //Display 3
    digitalWrite(display1, LOW);
    digitalWrite(display2, LOW);
    digitalWrite(display3, HIGH);
    desplegarNumero(decimal);
    desplegarPunto(0);
    delay(3);
}
